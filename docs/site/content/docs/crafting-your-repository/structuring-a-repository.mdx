---
title: 리포지토리 구조화하기
description: 생태계의 규칙을 사용하여 리포지토리를 생성하는 것부터 시작합니다.
---

import { Callout } from '#components/callout';
import { PackageManagerTabs, Tab, Tabs } from '#components/tabs';
import { Step, Steps } from '#components/steps';
import { File, Folder, Files } from '#components/files';
import { LinkToDocumentation } from '#components/link-to-documentation';

`turbo`는 JavaScript 생태계의 패키지 관리자 기능인 [Workspaces](https://vercel.com/docs/vercel-platform/glossary#workspace) 위에 구축되어 있으며, 이를 통해 하나의 리포지토리에 여러 패키지를 그룹화할 수 있습니다.

이러한 규칙을 따르는 것이 중요한 이유는 다음과 같습니다:

- 리포지토리의 모든 도구에 대해 해당 규칙을 활용할 수 있습니다
- 기존 리포지토리에 Turborepo를 빠르고 점진적으로 적용할 수 있습니다

이 가이드에서는 `turbo`의 기반을 마련할 수 있도록 멀티 패키지 워크스페이스(모노레포) 설정 과정을 안내합니다.

## 시작하기

워크스페이스 구조를 수동으로 설정하는 것은 번거로울 수 있습니다. 모노레포가 처음이라면 [올바른 워크스페이스 구조로 바로 시작할 수 있도록 `create-turbo` 사용](/docs/getting-started/installation)을 권장합니다.

<PackageManagerTabs>

<Tab value="pnpm">
```bash title="Terminal"
pnpm dlx create-turbo@latest
```

</Tab>

<Tab value="yarn">
```bash title="Terminal"
yarn dlx create-turbo@latest
```

</Tab>

<Tab value="npm">
```bash title="Terminal"
npx create-turbo@latest
```

</Tab>

<Tab value="bun (Beta)">
```bash title="Terminal"
bunx create-turbo@latest
```

</Tab>

</PackageManagerTabs>

그런 다음 이 가이드에 설명된 특성에 대해 리포지토리를 검토할 수 있습니다.

## 워크스페이스의 구조

JavaScript에서 워크스페이스는 [단일 패키지](/docs/guides/single-package-workspaces) 또는 패키지 모음일 수 있습니다. 이 가이드에서는 종종 "모노레포"라고 불리는 [멀티 패키지 워크스페이스](https://vercel.com/docs/vercel-platform/glossary#monorepo)에 초점을 맞춥니다.

아래는 유효한 워크스페이스로 만드는 `create-turbo`의 구조적 요소가 강조 표시되어 있습니다.

<PackageManagerTabs>

<Tab value="pnpm">
  <Files>
    <File name="package.json" green />
    <File name="pnpm-lock.yaml" green />
    <File name="pnpm-workspace.yaml" green />
    <File name="turbo.json" />
    <Folder name="apps" defaultOpen>
      <Folder name="docs" className="text-foreground" defaultOpen>
        <File name="package.json" green />
      </Folder>
      <Folder name="web">
        <File name="package.json" green />
      </Folder>
    </Folder>
    <Folder name="packages">
      <Folder name="ui">
        <File name="package.json" green />
      </Folder>
    </Folder>
  </Files>
</Tab>

<Tab value="yarn">
  <Files>
    <File name="package.json" green />
    <File name="yarn.lock" green />
    <File name="turbo.json" />
    <Folder name="apps" defaultOpen>
      <Folder name="docs" className="text-foreground" defaultOpen>
        <File name="package.json" green />
      </Folder>
      <Folder name="web">
        <File name="package.json" green />
      </Folder>
    </Folder>
    <Folder name="packages">
      <Folder name="ui">
        <File name="package.json" green />
      </Folder>
    </Folder>
  </Files>
</Tab>

<Tab value="npm">
  <Files>
    <File name="package.json" green />
    <File name="package-lock.json" green />
    <File name="turbo.json" />
    <Folder name="apps" defaultOpen>
      <Folder name="docs" className="text-foreground" defaultOpen>
        <File name="package.json" green />
      </Folder>
      <Folder name="web">
        <File name="package.json" green />
      </Folder>
    </Folder>
    <Folder name="packages">
      <Folder name="ui">
        <File name="package.json" green />
      </Folder>
    </Folder>
  </Files>
</Tab>

<Tab value="bun (Beta)">
  <Files>
    <File name="package.json" green />
    <File name="bun.lock" green />
    <File name="turbo.json" />
    <Folder name="apps" defaultOpen>
      <Folder name="docs" className="text-foreground" defaultOpen>
        <File name="package.json" green />
      </Folder>
      <Folder name="web">
        <File name="package.json" green />
      </Folder>
    </Folder>
    <Folder name="packages">
      <Folder name="ui">
        <File name="package.json" green />
      </Folder>
    </Folder>
  </Files>
</Tab>

</PackageManagerTabs>

### 최소 요구 사항

- [패키지 관리자가 설명하는 패키지](#specifying-packages-in-a-monorepo)
- [패키지 관리자 lockfile](#package-manager-lockfile)
- [루트 `package.json`](#root-packagejson)
- [루트 `turbo.json`](#root-turbojson)
- [각 패키지의 `package.json`](#packagejson-in-each-package)

### 모노레포에서 패키지 지정하기

<Steps>
<Step>

#### 패키지 디렉토리 선언하기

먼저 패키지 관리자가 패키지의 위치를 설명해야 합니다. 애플리케이션과 서비스를 위한 `apps/`와 라이브러리 및 도구 등 그 외의 모든 것을 위한 `packages/`로 패키지를 나누는 것부터 시작하는 것을 권장합니다.

<PackageManagerTabs>

  <Tab value="pnpm">
  ```json title="pnpm-workspace.yaml"
 packages:
    - "apps/*"
    - "packages/*"
  ```
  <LinkToDocumentation href="https://pnpm.io/pnpm-workspace_yaml">pnpm 워크스페이스 문서</LinkToDocumentation>

  </Tab>

  <Tab value="yarn">
  ```json title="./package.json"
  {
    "workspaces": [
      "apps/*",
      "packages/*"
    ]
  }
  ```

  <LinkToDocumentation href="https://yarnpkg.com/features/workspaces#how-are-workspaces-declared">yarn 워크스페이스 문서</LinkToDocumentation>
   </Tab>

  <Tab value="npm">
  ```json title="./package.json"
  {
    "workspaces": [
      "apps/*",
      "packages/*"
    ]
  }
  ```

  <LinkToDocumentation href="https://docs.npmjs.com/cli/v7/using-npm/workspaces#defining-workspaces">npm 워크스페이스 문서</LinkToDocumentation>
  </Tab>

  <Tab value="bun (Beta)">
  ```json title="./package.json"
  {
    "workspaces": [
      "apps/*",
      "packages/*"
    ]
  }
  ```

  <LinkToDocumentation href="https://bun.sh/docs/install/workspaces">bun 워크스페이스 문서</LinkToDocumentation>
  </Tab>

</PackageManagerTabs>

이 구성을 사용하면 `apps` 또는 `packages` 디렉토리에 **`package.json`이 있는** 모든 디렉토리가 패키지로 간주됩니다.

<Callout type="error">
Turborepo는 JavaScript 생태계의 패키지 관리자 간에 모호한 동작으로 인해 `apps/**` 또는 `packages/**`와 같은 중첩된 패키지를 지원하지 않습니다. `apps/a`에 패키지를, `apps/a/b`에 다른 패키지를 배치하는 구조를 사용하면 오류가 발생합니다.

디렉토리별로 패키지를 그룹화하려면 `packages/*` 및 `packages/group/*`와 같은 glob을 사용하고 `packages/group/package.json` 파일을 생성하지 **않으면** 됩니다.

</Callout>
</Step>

<Step>

#### 각 패키지의 `package.json`

패키지 디렉토리에는 패키지를 패키지 관리자와 `turbo`가 검색할 수 있도록 하는 `package.json`이 있어야 합니다. [패키지의 `package.json` 요구 사항](#anatomy-of-a-package)은 아래에 있습니다.

</Step>
</Steps>

### 루트 `package.json`

루트 `package.json`은 워크스페이스의 기반입니다. 아래는 루트 `package.json`에서 찾을 수 있는 일반적인 예입니다:

<PackageManagerTabs>

<Tab value="pnpm">

```json title="./package.json"
{
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "lint": "turbo run lint"
  },
  "devDependencies": {
    "turbo": "latest"
  },
  "packageManager": "pnpm@9.0.0"
}
```

</Tab>

<Tab value="yarn">

```json title="./package.json"
{
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "lint": "turbo run lint"
  },
  "devDependencies": {
    "turbo": "latest"
  },
  "packageManager": "yarn@1.22.19",
  "workspaces": ["apps/*", "packages/*"]
}
```

</Tab>

<Tab value="npm">

```json title="./package.json"
{
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "lint": "turbo run lint"
  },
  "devDependencies": {
    "turbo": "latest"
  },
  "packageManager": "npm@10.0.0",
  "workspaces": ["apps/*", "packages/*"]
}
```

</Tab>

<Tab value="bun (Beta)">

```json title="./package.json"
{
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "lint": "turbo run lint"
  },
  "devDependencies": {
    "turbo": "latest"
  },
  "packageManager": "bun@1.2.0",
  "workspaces": ["apps/*", "packages/*"]
}
```

</Tab>
</PackageManagerTabs>

### 루트 `turbo.json`

`turbo.json`은 `turbo`의 동작을 구성하는 데 사용됩니다. 작업 구성 방법에 대한 자세한 내용은 [작업 구성](/docs/crafting-your-repository/configuring-tasks) 페이지를 참조하세요.

### 패키지 관리자 lockfile

lockfile은 패키지 관리자와 `turbo` 모두에 대해 재현 가능한 동작의 핵심입니다. 또한 Turborepo는 lockfile을 사용하여 워크스페이스 내 [내부 패키지](/docs/core-concepts/internal-packages) 간의 의존성을 이해합니다.

<Callout type="warn">
  `turbo`를 실행할 때 lockfile이 없으면 예측할 수 없는 동작이 나타날 수
  있습니다.
</Callout>

## 패키지의 구조

워크스페이스 내에서 각 패키지를 고유한 단위로 설계하는 것부터 시작하는 것이 가장 좋습니다. 높은 수준에서 각 패키지는 자체 `package.json`, 도구 구성 및 소스 코드가 있는 자체 작은 "프로젝트"와 거의 같습니다. 이 아이디어에는 한계가 있지만 *시작*하기에 좋은 정신적 모델입니다.

또한 패키지에는 워크스페이스의 다른 패키지가 [`exports`](#exports)로 지정된 패키지에 액세스하는 데 사용할 수 있는 특정 진입점이 있습니다.

### 패키지의 `package.json`

#### `name`

[`name` 필드](https://nodejs.org/api/packages.html#name)는 패키지를 식별하는 데 사용됩니다. 워크스페이스 내에서 고유해야 합니다.

<Callout type="info">
npm 레지스트리의 다른 패키지와의 충돌을 피하기 위해 [내부 패키지](/docs/core-concepts/internal-packages)에 네임스페이스 접두사를 사용하는 것이 좋습니다. 예를 들어 조직 이름이 `acme`인 경우 패키지 이름을 `@acme/package-name`으로 지정할 수 있습니다.

문서와 예제에서는 npm 레지스트리에서 사용되지 않고 클레임할 수 없는 네임스페이스이기 때문에 `@repo`를 사용합니다. 그대로 유지하거나 자체 접두사를 사용할 수 있습니다.

</Callout>

#### `scripts`

`scripts` 필드는 패키지의 컨텍스트에서 실행할 수 있는 스크립트를 정의하는 데 사용됩니다. Turborepo는 이러한 스크립트의 이름을 사용하여 패키지에서 실행할 스크립트(있는 경우)를 식별합니다. 이러한 스크립트에 대한 자세한 내용은 [작업 실행](/docs/crafting-your-repository/running-tasks) 페이지에서 설명합니다.

#### `exports`

[`exports` 필드](https://nodejs.org/api/packages.html#exports)는 패키지를 사용하려는 다른 패키지의 진입점을 지정하는 데 사용됩니다. 한 패키지에서 다른 패키지의 코드를 사용하려는 경우 해당 진입점에서 가져옵니다.

예를 들어 `@repo/math` 패키지가 있는 경우 다음과 같은 `exports` 필드를 가질 수 있습니다:

```json title="./packages/math/package.json"
{
  "exports": {
    ".": "./src/constants.ts",
    "./add": "./src/add.ts",
    "./subtract": "./src/subtract.ts"
  }
}
```

이 예제는 단순화를 위해 [Just-in-Time 패키지](/docs/core-concepts/internal-packages#just-in-time-packages) 패턴을 사용합니다. TypeScript를 직접 내보내지만 대신 [컴파일된 패키지](/docs/core-concepts/internal-packages#compiled-packages) 패턴을 선택할 수도 있습니다.

<Callout type="info">
  이 예제의 `exports` 필드는 최신 버전의 Node.js 및 TypeScript가 필요합니다.
</Callout>

이를 통해 다음과 같이 `@repo/math` 패키지에서 `add` 및 `subtract` 함수를 가져올 수 있습니다:

```ts title="./apps/my-app/src/index.ts"
import { GRAVITATIONAL_CONSTANT, SPEED_OF_LIGHT } from '@repo/math';
import { add } from '@repo/math/add';
import { subtract } from '@repo/math/subtract';
```

이러한 방식으로 exports를 사용하면 세 가지 주요 이점이 있습니다:

- **배럴 파일 피하기**: 배럴 파일은 동일한 패키지의 다른 파일을 다시 내보내어 전체 패키지에 대한 하나의 진입점을 생성하는 파일입니다. 편리해 보일 수 있지만 [컴파일러와 번들러가 처리하기 어렵고](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js#what's-the-problem-with-barrel-files) 빠르게 성능 문제로 이어질 수 있습니다.
- **더 강력한 기능**: `exports`는 [조건부 Exports](https://nodejs.org/api/packages.html#conditional-exports)와 같은 [`main` 필드](https://nodejs.org/api/packages.html#main)에 비해 다른 강력한 기능도 있습니다. 일반적으로 가능한 한 `main` 대신 `exports`를 사용하는 것이 좋습니다. 이는 더 현대적인 옵션이기 때문입니다.
- **IDE 자동 완성**: `exports`를 사용하여 패키지의 진입점을 지정하면 코드 편집기가 패키지의 exports에 대한 자동 완성을 제공할 수 있습니다.

#### `imports` (선택 사항)

[`imports` 필드](https://nodejs.org/api/packages.html#imports)는 패키지 내의 다른 모듈에 대한 하위 경로를 만드는 방법을 제공합니다. 파일을 이동하는 리팩토링에 더 탄력적인 간단한 가져오기 경로를 작성하는 "바로 가기"와 같다고 생각할 수 있습니다. 방법을 알아보려면 [TypeScript 페이지](/docs/guides/tools/typescript#use-nodejs-subpath-imports-instead-of-typescript-compiler-paths)를 참조하세요.

<Callout type="info">
유사한 목표를 달성하는 TypeScript의 `compilerOptions#paths` 옵션에 더 익숙할 수 있습니다. TypeScript 5.4부터 TypeScript는 `imports`에서 하위 경로를 추론할 수 있으므로 Node.js 규칙과 함께 작업하게 되므로 더 나은 옵션입니다. 자세한 내용은 [TypeScript 가이드](/docs/guides/tools/typescript#use-nodejs-subpath-imports-instead-of-typescript-compiler-paths)를 참조하세요.

</Callout>

### 소스 코드

물론 패키지에 일부 소스 코드가 필요합니다. 패키지는 일반적으로 `src` 디렉토리를 사용하여 소스 코드를 저장하고 `dist` 디렉토리(패키지 내에도 위치해야 함)로 컴파일하지만 이는 요구 사항이 아닙니다.

## 일반적인 함정

- TypeScript를 사용하는 경우 워크스페이스의 루트에 `tsconfig.json`이 필요하지 않을 수 있습니다. 패키지는 일반적으로 워크스페이스의 별도 패키지에서 공유 `tsconfig.json`을 기반으로 자체 구성을 독립적으로 지정해야 합니다. 자세한 내용은 [TypeScript 가이드](/docs/guides/tools/typescript#you-likely-dont-need-a-tsconfigjson-file-in-the-root-of-your-project)를 참조하세요.
- 가능한 한 패키지 경계를 넘어 파일에 액세스하는 것을 피해야 합니다. 한 패키지에서 다른 패키지로 이동하기 위해 `../`를 작성하는 경우 필요한 곳에 패키지를 설치하고 코드로 가져와서 접근 방식을 다시 생각할 기회가 있을 수 있습니다.

## 다음 단계

워크스페이스가 구성되었으므로 이제 패키지 관리자를 사용하여 [패키지에 의존성을 설치](/docs/crafting-your-repository/managing-dependencies)할 수 있습니다.
