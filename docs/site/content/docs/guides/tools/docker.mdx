---
title: Docker
description: monorepo에서 Docker를 사용하는 방법을 알아보세요.
---

import { Callout } from '#components/callout';
import { File, Folder, Files } from '#components/files';
import { CreateTurboCallout } from './create-turbo-callout.tsx';

[Docker](https://www.docker.com/) 이미지를 빌드하는 것은 모든 종류의 애플리케이션을 배포하는 일반적인 방법입니다. 그러나 monorepo에서 이를 수행하는 것에는 몇 가지 과제가 있습니다.

<CreateTurboCallout />

## 문제점

**monorepo에서는 관련 없는 변경 사항이 앱을 배포할 때 Docker가 불필요한 작업을 수행하게 만들 수 있습니다.**

다음과 같은 monorepo가 있다고 가정해 봅시다:

<Files>
  <Folder name="apps" defaultOpen>
    <Folder name="api" defaultOpen>
      <File name="server.js" />
      <File name="package.json" />
    </Folder>
    <Folder name="web" defaultOpen>
      <File name="package.json" />
    </Folder>
  </Folder>
  <File name="package.json" />
  <File name="package-lock.json" />
</Files>

Docker를 사용하여 `apps/api`를 배포하려고 하므로 Dockerfile을 만듭니다:

```docker title="./apps/api/Dockerfile"
FROM node:16

WORKDIR /usr/src/app

# Copy root package.json and lockfile
COPY package.json ./
COPY package-lock.json ./

# Copy the api package.json
COPY apps/api/package.json ./apps/api/package.json

RUN npm install

# Copy app source
COPY . .

EXPOSE 8080

CMD [ "node", "apps/api/server.js" ]
```

이렇게 하면 루트 `package.json`과 루트 lockfile이 Docker 이미지로 복사됩니다. 그런 다음 종속성을 설치하고, 앱 소스를 복사하고, 앱을 시작합니다.

또한 node_modules가 앱의 소스와 함께 복사되는 것을 방지하기 위해 `.dockerignore` 파일을 만들어야 합니다.

```txt title=".dockerignore"
node_modules
npm-debug.log
```

### lockfile이 너무 자주 변경됩니다

Docker는 앱을 배포하는 방법에 대해 매우 똑똑합니다. Turborepo와 마찬가지로 [가능한 한 적은 작업](https://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/)을 수행하려고 합니다.

우리 Dockerfile의 경우, 이미지에 있는 파일이 이전 실행과 _다른_ 경우에만 `npm install`을 실행합니다. 그렇지 않으면 이전에 있던 `node_modules` 디렉터리를 복원합니다.

즉, `package.json`, `apps/api/package.json` 또는 `package-lock.json`이 변경될 때마다 Docker 이미지가 `npm install`을 실행합니다.

이것은 훌륭하게 들리지만, 우리는 무언가를 깨닫습니다. `package-lock.json`은 monorepo에 대해 *전역*입니다. 즉, **`apps/web` 내부에 새 패키지를 설치하면 `apps/api`가 재배포됩니다**.

대규모 monorepo에서는 monorepo의 lockfile에 대한 변경 사항이 수십 또는 수백 개의 배포로 이어지기 때문에 엄청난 시간 손실이 발생할 수 있습니다.

## 해결 방법

해결 방법은 Dockerfile에 대한 입력을 엄격하게 필요한 것으로만 제한하는 것입니다. Turborepo는 간단한 해결책인 `turbo prune`을 제공합니다.

```bash title="Terminal"
turbo prune api --docker
```

이 명령을 실행하면 `./out` 디렉터리 내에 **monorepo의 축소된 버전**이 생성됩니다. `api`가 의존하는 워크스페이스만 포함합니다. 또한 **lockfile을 축소**하여 관련 `node_modules`만 다운로드됩니다.

### `--docker` 플래그

기본적으로 `turbo prune`은 모든 관련 파일을 `./out` 내부에 넣습니다. 그러나 Docker로 캐싱을 최적화하려면 파일을 두 단계로 복사하는 것이 이상적입니다.

먼저, 패키지를 설치하는 데 필요한 것만 복사하려고 합니다. `--docker`를 실행하면 `./out/json` 내부에서 찾을 수 있습니다.

<Files>
  <Folder name="out" defaultOpen>
    <Folder name="json" defaultOpen>
      <Folder name="apps" defaultOpen>
        <Folder name="api" defaultOpen>
          <File name="package.json" />
        </Folder>
      </Folder>
      <File name="package.json" />
    </Folder>
    <Folder name="full" defaultOpen>
      <Folder name="apps" defaultOpen>
        <Folder name="api" defaultOpen>
          <File name="server.js" />
          <File name="package.json" />
        </Folder>
      </Folder>
      <File name="package.json" />
      <File name="turbo.json" />
    </Folder>
    <File name="package-lock.json" />
  </Folder>
</Files>

그런 다음 `./out/full`의 파일을 복사하여 소스 파일을 추가할 수 있습니다.

이렇게 **종속성**과 **소스 파일**을 분리하면 **종속성이 변경될 때만 `npm install`을 실행**할 수 있으므로 훨씬 더 큰 속도 향상을 얻을 수 있습니다.

<Callout type="info">
  `--docker` 없이는 모든 축소된 파일이 `./out` 내부에 배치됩니다.
</Callout>

### 예제

상세한 [`with-docker` 예제](https://github.com/vercel/turborepo/tree/main/examples/with-docker)는 `prune`을 최대한 활용하는 방법에 대해 자세히 설명합니다. 편의를 위해 Dockerfile을 복사했습니다.

monorepo의 루트에서 Dockerfile을 빌드합니다:

```bash title="Terminal"
docker build -f apps/web/Dockerfile .
```

<Callout type="info">
  이 Dockerfile은 `standalone` [output
  mode](https://nextjs.org/docs/pages/api-reference/next-config-js/output)를
  사용하는 [Next.js](https://nextjs.org/) 앱용으로 작성되었습니다.
</Callout>

```docker title="./apps/web/Dockerfile"
FROM node:18-alpine AS base

FROM base AS builder
RUN apk update
RUN apk add --no-cache libc6-compat
# Set working directory
WORKDIR /app
# Replace <your-major-version> with the major version installed in your repository. For example:
# RUN yarn global add turbo@^2
RUN yarn global add turbo@^<your-major-version>
COPY . .

# Generate a partial monorepo with a pruned lockfile for a target workspace.
# Assuming "web" is the name entered in the project's package.json: { name: "web" }
RUN turbo prune web --docker

# Add lockfile and package.json's of isolated subworkspace
FROM base AS installer
RUN apk update
RUN apk add --no-cache libc6-compat
WORKDIR /app

# First install the dependencies (as they change less often)
COPY --from=builder /app/out/json/ .
RUN yarn install --frozen-lockfile

# Build the project
COPY --from=builder /app/out/full/ .
RUN yarn turbo run build

FROM base AS runner
WORKDIR /app

# Don't run production as root
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
USER nextjs

# Automatically leverage output traces to reduce image size
# https://nextjs.org/docs/advanced-features/output-file-tracing
COPY --from=installer --chown=nextjs:nodejs /app/apps/web/.next/standalone ./
COPY --from=installer --chown=nextjs:nodejs /app/apps/web/.next/static ./apps/web/.next/static
COPY --from=installer --chown=nextjs:nodejs /app/apps/web/public ./apps/web/public

CMD node apps/web/server.js
```

## Remote Caching

Docker 빌드 중에 원격 캐시를 활용하려면 빌드 컨테이너가 [Remote Cache](/docs/core-concepts/remote-caching)에 액세스할 수 있는 자격 증명을 가지고 있어야 합니다.

Docker 이미지에서 시크릿을 처리하는 방법은 여러 가지가 있습니다. 여기서는 최종 이미지에 대해 숨겨질 빌드 인수로 시크릿을 사용하는 다단계 빌드를 사용하는 간단한 전략을 사용합니다.

위와 유사한 Dockerfile을 사용한다고 가정하고, `turbo build` 바로 전에 빌드 인수에서 일부 환경 변수를 가져옵니다:

```docker title="./apps/api/Dockerfile"
ARG TURBO_TEAM
ENV TURBO_TEAM=$TURBO_TEAM

ARG TURBO_TOKEN
ENV TURBO_TOKEN=$TURBO_TOKEN

RUN yarn turbo run build
```

`turbo`는 이제 Remote Cache에 도달할 수 있습니다. 캐시되지 않은 Docker 빌드 이미지에 대한 Turborepo 캐시 적중을 보려면 프로젝트 루트에서 다음과 같은 명령을 실행하세요:

```bash title="Terminal"
docker build -f apps/web/Dockerfile . --build-arg TURBO_TEAM=“your-team-name” --build-arg TURBO_TOKEN=“your-token“ --no-cache
```
