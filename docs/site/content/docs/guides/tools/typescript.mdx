---
title: TypeScript
description: monorepo에서 TypeScript를 사용하는 방법을 알아보세요.
---

import { Callout } from '#components/callout';
import { File, Folder, Files } from '#components/files';
import { PackageManagerTabs, Tabs, Tab } from '#components/tabs';
import { LinkToDocumentation } from '#components/link-to-documentation';

TypeScript는 monorepo에서 훌륭한 도구로, 팀이 JavaScript 코드에 안전하게 타입을 추가할 수 있습니다. 설정에 약간의 복잡성이 있지만, 이 가이드는 대부분의 사용 사례에 대한 TypeScript 설정의 중요한 부분을 안내합니다.

- [TypeScript 구성 공유](#sharing-tsconfigjson)
- [TypeScript 패키지 빌드](#building-a-typescript-package)
- [워크스페이스 전체에서 타입 검사를 더 빠르게 만들기](/docs/guides/tools/typescript#linting-your-codebase)

<Callout type="info">
  이 가이드는 최신 버전의 TypeScript를 사용한다고 가정하며 해당 버전에서만
  사용할 수 있는 일부 기능을 사용합니다. 해당 버전의 기능을 사용할 수 없는 경우
  이 페이지의 지침을 조정해야 할 수 있습니다.
</Callout>

## `tsconfig.json` 공유

TypeScript 구성에 일관성을 구축하여 전체 저장소가 훌륭한 기본값을 사용할 수 있고 동료 개발자가 Workspace에서 코드를 작성할 때 무엇을 기대할 수 있는지 알 수 있기를 원합니다.

TypeScript의 `tsconfig.json`은 TypeScript 컴파일러에 대한 구성을 설정하며 워크스페이스 전체에서 구성을 공유하는 데 사용할 [`extends` 키](https://www.typescriptlang.org/tsconfig#extends)를 제공합니다.

이 가이드는 예제로 [`create-turbo`](/docs/reference/create-turbo)를 사용합니다.

<PackageManagerTabs>

<Tab value="pnpm">

```bash title="Terminal"
pnpm dlx create-turbo@latest
```

</Tab>

<Tab value="yarn">

```bash title="Terminal"
yarn dlx create-turbo@latest
```

</Tab>

<Tab value="npm">

```bash title="Terminal"
npx create-turbo@latest
```

</Tab>

<Tab value="bun (Beta)">

```bash title="Terminal"
bunx create-turbo@latest
```

</Tab>
</PackageManagerTabs>

### 기본 `tsconfig` 파일 사용

`packages/typescript-config` 내부에는 다양한 패키지에서 TypeScript를 구성하려는 여러 가지 방법을 나타내는 몇 개의 `json` 파일이 있습니다. `base.json` 파일은 워크스페이스의 다른 모든 `tsconfig.json`에 의해 확장되며 다음과 같습니다:

```json title="./packages/typescript-config/base.json"
{
  "compilerOptions": {
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "module": "NodeNext"
  }
}
```

<LinkToDocumentation href="https://www.typescriptlang.org/tsconfig">
  `tsconfig` options reference
</LinkToDocumentation>

### 나머지 패키지 만들기

이 패키지의 다른 `tsconfig` 파일은 `extends` 키를 사용하여 기본 구성으로 시작하고 Next.js(`nextjs.json`) 및 React 라이브러리(`react-library.json`)와 같은 특정 유형의 프로젝트에 맞게 사용자 지정합니다.

`package.json` 내부에서 Workspace의 나머지 부분에서 참조할 수 있도록 패키지 이름을 지정합니다:

```json title="packages/typescript-config/package.json"
{
  "name": "@repo/typescript-config"
}
```

## TypeScript 패키지 빌드

### 구성 패키지 사용

먼저, `@repo/typescript-config` 패키지를 패키지에 설치합니다:

<PackageManagerTabs>

<Tab value="pnpm">
```json title="./apps/web/package.json"
{
  "devDependencies": {
     "@repo/typescript-config": "workspace:*",
     "typescript": "latest",
  }
}
```
</Tab>

<Tab value="yarn">
```json title="./apps/web/package.json"
{
  "devDependencies": {
     "@repo/typescript-config": "*",
     "typescript": "latest",
  }
}
```
</Tab>

<Tab value="npm">
```json title="./apps/web/package.json"
{
  "devDependencies": {
     "@repo/typescript-config": "*",
     "typescript": "latest",
  }
}
```
</Tab>

<Tab value="bun (Beta)">
```json title="./apps/web/package.json"
{
  "devDependencies": {
     "@repo/typescript-config": "workspace:*",
     "typescript": "latest",
  }
}
```
</Tab>
</PackageManagerTabs>

그런 다음 `@repo/typescript-config` 패키지에서 패키지에 대한 `tsconfig.json`을 확장합니다. 이 예제에서 `web` 패키지는 Next.js 애플리케이션입니다:

```json title="./apps/web/tsconfig.json"
{
  "extends": "@repo/typescript-config/nextjs.json",
  "compilerOptions": {
    "outDir": "dist"
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}
```

### 패키지에 대한 진입점 만들기

먼저, `dist` 디렉터리가 있도록 코드가 `tsc`로 컴파일되었는지 확인합니다. `build` 스크립트와 `dev` 스크립트가 필요합니다:

```json title="./packages/ui/package.json"
{
  "scripts": {
    "dev": "tsc --watch",
    "build": "tsc"
  }
}
```

Then, set up the entrypoints for your package in `package.json` so that other packages can use the compiled code:

```json title="./packages/ui/package.json"
{
  "exports": {
    "./*": {
      "types": "./src/*.ts",
      "default": "./dist/*.js"
    }
  }
}
```

Setting up `exports` this way has several advantages:

- Using the `types` field allows `tsserver` to use the code in `src` as the source of truth for your code's types. Your editor will always be up-to-date with the latest interfaces from your code.
- You can quickly add new entrypoints to your package without creating [dangerous barrel files](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js#what's-the-problem-with-barrel-files).
- You'll receive auto-importing suggestions for your imports across package boundaries in your editor.

<Callout type="warn">
  If you're publishing the package, you cannot use references to source code in
  `types` since only the compiled code will be published to npm. You'll need to
  generate and reference declaration files and source maps.
</Callout>

## Linting your codebase

To use TypeScript as a linter, you can check the types across your workspace **fast** using Turborepo's caching and parallelization.

First, add a `check-types` script to any package that you want to check the types for:

```json title="./apps/web/package.json"
{
  "scripts": {
    "check-types": "tsc --noEmit"
  }
}
```

Then, create a `check-types` task in `turbo.json`. From the [Configuring tasks guide](/docs/crafting-your-repository/configuring-tasks#dependent-tasks-that-can-be-run-in-parallel), we can make the task run in parallel while respecting source code changes from other packages using a [Transit Node](/docs/core-concepts/package-and-task-graph#transit-nodes):

```json title="./turbo.json"
{
  "tasks": {
    "topo": {
      "dependsOn": ["^topo"]
    },
    "check-types": {
      "dependsOn": ["topo"]
    }
  }
}
```

Then, run your task using `turbo check-types`.

## Best practices

### Use `tsc` to compile your packages

For [Internal Packages](/docs/core-concepts/internal-packages), we recommend that you use `tsc` to compile your TypeScript libraries whenever possible. While you can use a bundler, it's not necessary and adds extra complexity to your build process. Additionally, bundling a library can mangle the code before it makes it to your applications' bundlers, causing hard to debug issues.

### Enable go-to-definition across package boundaries

"Go-to-definition" is an editor feature for quickly navigating to the original declaration or definition of a symbol (like a variable or function) with a click or hotkey. Once TypeScript is configured correctly, you can navigate across [Internal Packages](/docs/core-concepts/internal-packages) with ease.

#### Just-in-Time Packages

Exports from [Just-in-Time Packages](/docs/core-concepts/internal-packages#just-in-time-packages) will automatically bring you to the original TypeScript source code. Go-to-definition will work as expected.

#### Compiled Packages

Exports from [Compiled Packages](/docs/core-concepts/internal-packages#compiled-packages) require the use of [`declaration`](https://www.typescriptlang.org/tsconfig/#declaration) and [`declarationMap`](https://www.typescriptlang.org/tsconfig/#declarationMap) configurations for go-to-definition to work. After you've enabled these two configurations for the package, compile the package with `tsc`, and open the output directory to find declaration files and source maps.

<Files>
  <Folder defaultOpen name="packages">
    <Folder defaultOpen name="ui">
      <Folder defaultOpen name="dist">
        <File name="button.js" />
        <File name="button.d.ts" green />
        <File name="button.d.ts.map" green />
      </Folder>
    </Folder>
  </Folder>
</Files>

With these two files in place, your editor will now navigate to the original source code.

### Use Node.js subpath imports instead of TypeScript compiler `paths`

It's possible to create absolute imports in your packages using [the TypeScript compiler's `paths` option](https://www.typescriptlang.org/tsconfig#paths), but these paths can cause failed compilation when using [Just-in-Time Packages](https://turborepo.com/docs/core-concepts/internal-packages#just-in-time-packages). [As of TypeScript 5.4](https://devblogs.microsoft.com/typescript/announcing-typescript-5-4/#auto-import-support-for-subpath-imports), you can use [Node.js subpath imports](https://nodejs.org/api/packages.html#imports) instead for a more robust solution.

#### Just-in-Time Packages

In [Just-in-Time packages](https://turborepo.com/docs/core-concepts/internal-packages#just-in-time-packages), `imports` must target the source code in the package, since build outputs like `dist` won't be created.

<Tabs storageKey="ts-imports-jit" items={["package.json", "Source code"]}>
  <Tab value="package.json">
```json title="./packages/ui/package.json"
{
  "imports": {
    "#*": "./src/*"
  }
}
```
</Tab>
<Tab value="Source code">
```tsx title="./packages/ui/button.tsx"
import { MY_STRING } from "#utils.ts" // Uses .ts extension // [!code highlight]

export const Button = () => {
  return (
    <button>{MY_STRING}</button>
  )
}
```
</Tab>

</Tabs>

#### Compiled Packages

In [Compiled packages](https://turborepo.com/docs/core-concepts/internal-packages#compiled-packages), `imports` target the built outputs for the package.

<Tabs storageKey="ts-imports-compiled" items={["package.json", "Source code"]}>
  <Tab value="package.json">
```json title="./packages/ui/package.json"
{
  "imports": {
    "#*": "./dist/*"
  }
}
```
</Tab>

  <Tab value="Source code">

```tsx title="./packages/ui/button.tsx"
import { MY_STRING } from '#utils.js'; // Uses .js extension // [!code highlight]

export const Button = () => {
  return <button>{MY_STRING}</button>;
};
```

</Tab>

</Tabs>

### You likely don't need a `tsconfig.json` file in the root of your project

As mentioned in the [Structuring your repository guide](/docs/crafting-your-repository/structuring-a-repository#anatomy-of-a-package), you want to treat each package in your tooling as its own unit. This means each package should have its own `tsconfig.json` to use instead of referencing a `tsconfig.json` in the root of your project. Following this practice will make it easier for Turborepo to cache your type checking tasks, simplifying your configuration.

The only case in which you may want to have a `tsconfig.json` in the Workspace root is to set configuration for TypeScript files that are not in packages. For example, if you have a script written with TypeScript that you need to run from the root, you may need a `tsconfig.json` for that file.

However, this practice is also discouraged since any changes in the Workspace root will cause all tasks to miss cache. Instead, move those scripts to a different directory in the repository.

### You likely don't need TypeScript Project References

We don't recommend using TypeScript Project References as they introduce both another point of configuration as well as another caching layer to your workspace. Both of these can cause problems in your repository with little benefit, so we suggest avoiding them when using Turborepo.

## Limitations

### Your editor won't use a package's TypeScript version

`tsserver` is not able to use different TypeScript versions for different packages in your code editor. Instead, it will discover a specific version and use that everywhere.

This can result in differences between the linting errors that show in your editor and when you run `tsc` scripts to check types. If this is an issue for you, consider [keeping the TypeScript dependency on the same version](/docs/crafting-your-repository/managing-dependencies#keeping-dependencies-on-the-same-version).
