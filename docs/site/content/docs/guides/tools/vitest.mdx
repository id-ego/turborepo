---
title: Vitest
description: monorepo에서 Vitest를 사용하는 방법을 알아보세요.
---

import { Callout } from '#components/callout';
import { File, Folder, Files } from '#components/files';
import { CreateTurboCallout } from './create-turbo-callout.tsx';
import { Tab, Tabs } from '#components/tabs';

[Vitest](https://vitest.dev/)는 Vite 생태계의 테스트 러너입니다. Turborepo와 통합하면 엄청난 속도 향상을 얻을 수 있습니다.

[Vitest 문서](https://vitest.dev/guide/workspace)는 하나의 루트 명령에서 monorepo의 모든 테스트를 실행하는 "Vitest Projects" 구성을 만드는 방법을 보여줍니다. 이는 병합된 커버리지 보고서와 같은 동작을 즉시 가능하게 합니다. 이 기능은 monorepo에 대한 현대적인 모범 사례를 따르지 않는데, Jest와의 호환성을 위해 설계되었기 때문입니다(Jest의 Workspace 기능은 [패키지 관리자 Workspaces](/docs/crafting-your-repository/structuring-a-repository) 이전에 구축되었습니다).

<Callout type="warning">
  Vitest는 projects를 위해 workspaces를 더 이상 사용하지 않습니다. projects를
  사용할 때 개별 프로젝트 vitest 구성은 projects 구성을 상속하므로 더 이상 루트
  구성을 확장할 수 없습니다. 대신 `vitest.shared.ts`와 같은 별도의 공유 파일이
  필요합니다.
</Callout>

이 때문에 각각 고유한 장단점이 있는 두 가지 옵션이 있습니다:

- [캐싱을 위한 Turborepo 활용](#leveraging-turborepo-for-caching)
- [Vitest의 Projects 기능 사용](#using-vitests-projects-feature)

### 캐싱을 위한 Turborepo 활용

캐시 적중률을 개선하고 변경된 테스트만 실행하려면 패키지별로 작업을 구성하여 Vitest 명령을 각 패키지의 별도 캐시 가능한 스크립트로 분할할 수 있습니다. 이 속도는 병합된 커버리지 보고서를 직접 만들어야 한다는 절충안을 수반합니다.

<Callout>
  완전한 예제를 보려면 `npx create-turbo@latest --example with-vitest`를
  실행하거나 [예제의 소스 코드를
  방문하세요](https://github.com/vercel/turborepo/tree/main/examples/with-vitest).
</Callout>

#### 설정

다음과 같은 간단한 [패키지 관리자 Workspace](/docs/crafting-your-repository/structuring-a-repository)가 있다고 가정해 봅시다:

<Files>
  <Folder name="apps" defaultOpen>
    <Folder name="web" defaultOpen>
      <File name="package.json" />
    </Folder>
  </Folder>
  <Folder name="packages" defaultOpen>
    <Folder name="ui" defaultOpen>
      <File name="package.json" />
    </Folder>
  </Folder>
</Files>

`apps/web`과 `packages/ui` 모두 자체 테스트 스위트가 있으며, `vitest`가 [사용하는 패키지에 설치됩니다](/docs/crafting-your-repository/managing-dependencies#install-dependencies-where-theyre-used). `package.json` 파일에는 Vitest를 실행하는 `test` 스크립트가 포함되어 있습니다:

```json title="./apps/web/package.json"
{
  "scripts": {
    "test": "vitest run"
  },
  "devDependencies": {
    "vitest": "latest"
  }
}
```

루트 `turbo.json` 내부에 `test` 작업을 만듭니다:

```json title="./turbo.json"
{
  "tasks": {
    "test": {
      "dependsOn": ["transit"]
    },
    "transit": {
      "dependsOn": ["^transit"]
    }
  }
}
```

이제 `turbo run test`는 각 패키지의 모든 테스트 스위트를 병렬화하고 캐시하여 변경된 코드만 테스트합니다.

#### watch 모드에서 테스트 실행

CI에서 테스트 스위트를 실행하면 결과를 기록하고 완료 시 종료됩니다. 즉, [Turborepo로 캐시할 수 있습니다](/docs/crafting-your-repository/caching). 그러나 개발 중에 Vitest의 watch 모드를 사용하여 테스트를 실행하면 프로세스가 종료되지 않습니다. 이로 인해 watch 작업은 [장기 실행 개발 작업](/docs/crafting-your-repository/developing-applications)과 더 비슷합니다.

이러한 차이로 인해 **두 개의 별도 Turborepo 작업**을 지정하는 것을 권장합니다: 하나는 테스트를 실행하는 것이고, 다른 하나는 watch 모드에서 실행하는 것입니다.

<Callout>
  아래 전략은 두 가지 작업을 만듭니다. 하나는 로컬 개발용이고 다른 하나는
  CI용입니다. 로컬 개발용으로 `test` 작업을 만들고 대신 `test:ci` 작업을 만들
  수도 있습니다.
</Callout>

예를 들어, 각 워크스페이스의 `package.json` 파일 내부에:

```json title="./apps/web/package.json"
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest --watch"
  }
}
```

And, inside the root `turbo.json`:

```json title="./turbo.json"
{
  "tasks": {
    "test": {
      "dependsOn": ["^test"]
    },
    "test:watch": {
      "cache": false,
      "persistent": true
    }
  }
}
```

You can now run your tasks using [global `turbo`](/docs/getting-started/installation#global-installation) as `turbo run test:watch` or from a script in your root `package.json`:

<Tabs items={["Global turbo", "./package.json"]}>
<Tab value="Global turbo">

```bash title="Terminal"
turbo run test

turbo run test:watch
```

</Tab>

<Tab value="./package.json">

```json title="./package.json"
{
  "scripts": {
    "test": "turbo run test",
    "test:watch": "turbo run test:watch"
  }
}
```

</Tab>

</Tabs>

#### Creating merged coverage reports

[Vitest's Projects feature](#using-vitests-projects-feature) creates an out-of-the-box coverage report that merges all of your packages' tests coverage reports. Following the Turborepo strategy, though, you'll have to merge the coverage reports yourself.

<Callout type="info">
  The [`with-vitest`
  example](https://github.com/vercel/turborepo/tree/main/examples/with-vitest)
  shows a complete example that you may adapt for your needs. You can get
  started with it quickly using `npx create-turbo@latest --example with-vitest`.
</Callout>

To do this, you'll follow a few general steps:

1. Run `turbo run test` to create the coverage reports.
2. Merge the coverage reports with [`nyc merge`](https://github.com/istanbuljs/nyc?tab=readme-ov-file#what-about-nyc-merge).
3. Create a report using `nyc report`.

Turborepo tasks to accomplish will look like:

```json title="./turbo.json"
{
  "tasks": {
    "test": {
      "dependsOn": ["^test", "@repo/vitest-config#build"],
      "outputs": ["coverage.json"]
    }
    "merge-json-reports": {
      "inputs": ["coverage/raw/**"],
      "outputs": ["coverage/merged/**"]
    },
    "report": {
      "dependsOn": ["merge-json-reports"],
      "inputs": ["coverage/merge"],
      "outputs": ["coverage/report/**"]
    },
  }
}
```

With this in place, run `turbo test && turbo report` to create a merged coverage report.

<Callout type="info">
  The [`with-vitest`
  example](https://github.com/vercel/turborepo/tree/main/examples/with-vitest)
  shows a complete example that you may adapt for your needs. You can get
  started with it quickly using `npx create-turbo@latest --example with-vitest`.
</Callout>

### Using Vitest's Projects feature

The Vitest Projects feature doesn't follow the same model as a [package manager Workspace](/docs/crafting-your-repository/structuring-a-repository). Instead, it uses a root script that then reaches out into each package in the repository to handle the tests in that respective package.

In this model, there aren't package boundaries, from a modern JavaScript ecosystem perspective. This means you can't rely on Turborepo's caching, since Turborepo leans on those package boundaries.

Because of this, you'll need to use [Root Tasks](/docs/crafting-your-repository/configuring-tasks#registering-root-tasks) if you want to run the tests using Turborepo. Once you've configured [a Vitest Projects setup](https://vitest.dev/guide/workspace), create the Root Tasks for Turborepo:

```json title="./turbo.json"
{
  "tasks": {
    "//#test": {
      "outputs": ["coverage/**"]
    },
    "//#test:watch": {
      "cache": false,
      "persistent": true
    }
  }
}
```

**Notably, the file inputs for a Root Task include all packages by default, so any change in any package will result in a cache miss.** While this does make for a simplified configuration to create merged coverage reports, you'll be missing out on opportunities to cache repeated work.

### Using a hybrid approach

You can combine the benefits of both approaches by implementing a hybrid solution. This approach unifies local development using Vitest's Projects feature while preserving Turborepo's caching in CI. This comes at the tradeoff of slightly more configuration and a mixed task running model in the repository.

First, create a shared configuration package since individual projects can't extend the root config when using projects. Create a new package for your shared Vitest configuration:

```json title="./packages/vitest-config/package.json"
{
  "name": "@repo/vitest-config",
  "version": "0.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "dependencies": {
    "vitest": "latest"
  },
  "devDependencies": {
    "@repo/typescript-config": "workspace:*",
    "typescript": "latest"
  }
}
```

```json title="./packages/vitest-config/tsconfig.json"
{
  "extends": "@repo/typescript-config/base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"],
  "exclude": ["dist", "node_modules"]
}
```

```ts title="./packages/vitest-config/src/index.ts"
export const sharedConfig = {
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    // Other shared configuration
  },
};
```

Then, create your root Vitest configuration using projects:

```ts title="./vitest.config.ts"
import { defineConfig } from 'vitest/config';
import { sharedConfig } from '@repo/vitest-config';

export default defineConfig({
  ...sharedConfig,
  projects: [
    {
      name: 'packages',
      root: './packages/*',
      test: {
        ...sharedConfig.test,
        // Project-specific configuration
      },
    },
  ],
});
```

In this setup, your packages maintain their individual Vitest configurations that import the shared config. First, install the shared config package:

```json title="./packages/ui/package.json"
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest --watch"
  },
  "devDependencies": {
    "@repo/vitest-config": "workspace:*",
    "vitest": "latest"
  }
}
```

Then create the Vitest configuration:

```ts title="./packages/ui/vitest.config.ts"
import { defineConfig } from 'vitest/config';
import { sharedConfig } from '@repo/vitest-config';

export default defineConfig({
  ...sharedConfig,
  test: {
    ...sharedConfig.test,
    // Package-specific overrides if needed
  },
});
```

Make sure to update your `turbo.json` to include the new configuration package in the dependency graph:

```json title="./turbo.json"
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "test": {
      "dependsOn": ["^test", "@repo/vitest-config#build"]
    },
    "test:watch": {
      "cache": false,
      "persistent": true
    }
  }
}
```

While your root `package.json` includes scripts for running tests globally:

```json title="./package.json"
{
  "scripts": {
    "test:projects": "vitest run",
    "test:projects:watch": "vitest --watch"
  }
}
```

This configuration allows developers to run `pnpm test:projects` or `pnpm test:projects:watch` at the root for a seamless local development experience using Vitest projects, while CI continues to use `turbo run test` to leverage package-level caching. **You'll still need to handle merged coverage reports manually as described in the previous section**.
